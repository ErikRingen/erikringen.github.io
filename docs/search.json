[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am a Data Scientist at the University of Zürich, where I do applied statistics and teach probabalistic modelling to graduate students. My PhD was in Biological Anthropology, where I focused on developing phylogenetic comparative methods using Stan.\nAs a consultant, I solve a diverse array of modelling problems in the social and behavioral sciences. Many of these solutions are likely be useful to others, but they end up buried in the supplementary materials of academic publications. So from time-to-time I will write them up as blog posts here."
  },
  {
    "objectID": "posts/OLRE/index.html",
    "href": "posts/OLRE/index.html",
    "title": "The right way to do predictive checks with observation-level random effects",
    "section": "",
    "text": "Observation-level random effects (OLRE) are an effective way to model overdispersed count data (Harrison 2014). For example, OLREs relax the assumption of Poisson regression that the variance is equal to the mean by giving each observation \\(i\\) a “random intercept” (\\(\\nu_i\\)):\n\\[ y_i \\sim \\text{Poisson}(\\lambda_i)\\] \\[ \\text{log}(\\lambda_i) = b_0 + \\nu_i\\] \\[ \\nu_i \\sim \\mathcal{N} (0, \\sigma) \\]\nBy putting \\(\\nu\\) inside the linear model, we smuggle a variance component (\\(\\sigma\\)) into a distribution that otherwise has only a single rate parameter (this trick also works for the Binomial distribution (Harrison 2015)). OLREs are also used to capture residual correlations in multi-response models (Hadfield 2010)\nPredictive checks are a routine form of model checking used to understand a model’s ability to represent the data. Unfortunately, most software for performing predictive checks will handle OLREs the wrong way by default, giving an inflated goodness-of-fit. In this post I will show you how to do it the right way, in either R + brms or Python + PyMC. Here I focus on Bayesian models, but the basic idea would also hold for checking frequentist models with software such as lme4 and glmmTMB.\n\nThe wrong way\nIn Bayesian workflow, we often perform posterior predictive checks, where draws from the posterior distribution are used to generate many synthetic replications of our dataset, denoted \\(y_{\\text{rep}}\\), which are then compared to the observed values. Systematic discrepancies between the distribution of \\(y_\\text{rep}\\) and the actual data indicate misspecification, and can suggest ways to improve our models.\nTo illustrate this idea, we’ll use the Oceanic toolkit complexity dataset from Michelle Kline and Robert Boyd (Kline and Boyd 2010). The response variable is the count of unique tools in a given Oceanic society (total_tools), which is predicted by the natural logarithm of population size (population). First we will fit this basic model, using priors from (McElreath 2020). For each society \\(i\\):\n\\[ \\text{total\\_tools}_i \\sim \\text{Poisson}(\\lambda_i)\\] \\[ \\text{log}(\\lambda_i) = b_0 + b_{\\text{pop}}\\text{log}(\\text{population}_{z_i})\\] \\[ b_0 \\sim \\mathcal{N}(3, 0.5)\\] \\[ b_{\\text{pop}} \\sim \\mathcal{N}(0, 0.2)\\]\nThen, we will perform posterior predictive checks using some off-the-shelf convenience functions.\n\nbrmsPyMC\n\n\n\n\nCode\nlibrary(brms)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(bayesplot)\nlibrary(tidybayes)\nlibrary(patchwork)\nset.seed(123)\n\nKline &lt;- read.csv(\"https://raw.githubusercontent.com/rmcelreath/rethinking/refs/heads/master/data/Kline.csv\", sep=\";\")\n\nKline$log_pop_z &lt;- scale(log(Kline$population)) # standardize\n\nm_poisson &lt;- brm(\n    total_tools ~ 1 + log_pop_z,\n    family = poisson(link = \"log\"),\n    prior = prior(normal(3, 0.5), class = \"Intercept\") + \n        prior(normal(0, 0.2), class = \"b\"),\n    chains = 1,\n    data = Kline,\n    seed = 123)\n\ncolor_scheme_set(\"teal\")\ntheme_set(theme_classic(base_size = 13))\n\nbrms::pp_check(m_poisson, type = \"dens_overlay\", ndraws = 200) + \n    theme(legend.position = \"none\") + \n    brms::pp_check(m_poisson, type = \"intervals\") + \n    plot_layout(guides = 'collect') + \n    theme_classic(base_size = 13) +\n    plot_annotation(subtitle = \"Basic Poisson PPC\") \n\n\n\n\n\nPosterior predictive checks for basic Poisson model. (left) replicated and observed densities, (right) observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\n\nCode\nimport matplotlib.colors as cols\nimport matplotlib.pyplot as plt\nplt.rcParams.update({\n    'font.size': 30,\n    'axes.titlesize': 32,         \n    'axes.labelsize': 30,        \n    'xtick.labelsize': 28,      \n    'ytick.labelsize': 28, \n    'legend.fontsize': 32,\n    'lines.linewidth': 1.5,\n})\n\nimport pandas as pd\nimport pymc as pm\nimport numpy as np\nfrom scipy import stats\nfrom scipy.stats import gaussian_kde\nimport arviz as az\n\nKline = pd.read_csv(\"https://raw.githubusercontent.com/rmcelreath/rethinking/refs/heads/master/data/Kline.csv\", sep=\";\")\n\nKline['log_pop_z'] = stats.zscore(np.log(Kline['population']))\n\nwith pm.Model() as m_poisson:\n    # priors\n    b0 = pm.Normal(\"Intercept\", mu=3, sigma=0.5)\n    b_pop = pm.Normal(\"slope\", mu=0, sigma=0.2)\n    # linear model\n    log_lam = b0 + b_pop * Kline['log_pop_z']\n    ## Poisson likelihood\n    y = pm.Poisson(\"y\", mu=pm.math.exp(log_lam), observed=Kline['total_tools'])\n\n    idata = pm.sample(4000, chains=1, random_seed=123)\n    pm.sample_posterior_predictive(idata, extend_inferencedata=True, random_seed=1);\n\n\nCode\n\n\nidata.observed_data['y'] = idata.observed_data['y'].astype(np.float64) # Convert observed data to float for visualization\nidata.posterior_predictive['y'] = idata.posterior_predictive['y'].astype(np.float64)\n\n# Define plot functions\ndef plot_ppc_dens(y, yrep, ax, ax_index, num_samples=200):\n    yrep = yrep.values\n    y = y.values \n\n    for i in range(num_samples):\n        sample = yrep[0, i, :]\n        kde_sample = gaussian_kde(sample)\n        x_values = np.linspace(yrep.min(), yrep.max(), 200)\n        ax[ax_index].plot(x_values, kde_sample(x_values), color=(0.0, 0.486, 0.486, 0.05))  # Use low alpha for transparency\n\n    kde = gaussian_kde(y)\n    x_values = np.linspace(yrep.min(), yrep.max(), 200)\n    ax[ax_index].plot(x_values, kde(x_values), color=\"#007c7c\", linewidth=6)\n\n    ax[ax_index].set_xlabel('')\n    ax[ax_index].set_ylabel('')\n    ax[ax_index].margins(y=0)\n    ax[ax_index].margins(x=0)\n    ax[ax_index].spines['top'].set_visible(False)\n    ax[ax_index].spines['right'].set_visible(False)\n\ndef plot_ppc_intervals(y, yrep, ax, ax_index):\n    y = y.values\n    yrep = yrep.stack(sample=(\"chain\", \"draw\")).values\n\n    median_predictions = np.median(yrep, axis=1)\n\n    # Define x-axis values\n    x = np.arange(len(y))\n\n    intervals = [(25, 75), (5, 95)]\n    colors = ['#007C7C', '#007C7C']\n    labels = ['50% Interval', '90% Interval']\n\n    for (low, high), color, label in zip(intervals, colors, labels):\n        lower_bounds = np.percentile(yrep, low, axis=1)\n        upper_bounds = np.percentile(yrep, high, axis=1)\n        error_lower = median_predictions - lower_bounds\n        error_upper = upper_bounds - median_predictions\n        error = [error_lower, error_upper]\n\n        ax[ax_index].errorbar(\n        x,\n        median_predictions,\n        yerr=error,\n        fmt='o',\n        color='#007C7C',\n        ecolor=color,\n        elinewidth=8,\n        capsize=0,\n        label=label,\n        alpha=0.1,\n        markersize=20\n    )\n\n    # Overlay observed data points\n    ax[ax_index].scatter(\n        x,\n        y,\n        color='#007C7C',\n        label='Observed Data',\n        zorder=5,\n        s = 150\n    )\n\n    # Customize the plot\n    ax[ax_index].set_xlabel('Data point (index)')\n    ax[ax_index].set_ylabel('')\n    ax[ax_index].set_title('')\n    ax[ax_index].legend(['y', 'yrep'], loc=\"upper left\")\n    ax[ax_index].spines['top'].set_visible(False)\n    ax[ax_index].spines['right'].set_visible(False)\n\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 13))\n\nplot_ppc_dens(idata.observed_data['y'], idata.posterior_predictive['y'], axes, 0)\nplot_ppc_intervals(idata.observed_data['y'], idata.posterior_predictive['y'], axes, 1)\naxes[0].set_title('Basic Poisson PPC', loc = \"left\")\n\n\n\n\n\nPosterior predictive checks for basic Poisson model. (left) replicated and observed densities, (right) observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\nWe see some indications that the data are overdispersed, relative to the model. Namely, the distribution of the observed \\(y\\) (total_tools) appears “flat” compared to \\(y_{\\text{rep}}\\) in the left-side plot. We can also see in the right-side plot that several observed values fall outside of the 90% credible intervals, suggesting that the model’s predictions are too precise. So, lets try adding an OLRE to capture this overdispersion. Here’s our updated model definition:\n\\[ \\text{total\\_tools}_i \\sim \\text{Poisson}(\\lambda_i)\\] \\[ \\text{log}(\\lambda_i) = b_0 + \\nu_i + b_{\\text{pop}}\\text{log}(\\text{population}_{z_i})\\] \\[ b_0 \\sim \\mathcal{N}(3, 0.5)\\] \\[ b_{\\text{pop}} \\sim \\mathcal{N}(0, 0.2)\\] \\[ \\nu_i \\sim \\mathcal{N}(0, \\sigma)\\] \\[ \\sigma \\sim \\text{Exponential}(2) \\]\n\nbrmsPyMC\n\n\n\n\nCode\nKline$obs &lt;- 1:nrow(Kline)\n\nm_poisson_OLRE &lt;- brm(\n    total_tools ~ 1 + log_pop_z + (1|obs),\n    family = poisson(link = \"log\"),\n    prior = prior(normal(3, 0.5), class = \"Intercept\") + \n        prior(normal(0, 0.2), class = \"b\") + \n        prior(exponential(2), class = \"sd\"),\n    chains = 1,\n    control = list(adapt_delta = 0.95),\n    data = Kline,\n    seed=123,\n    save_pars = save_pars(all = TRUE))\n\nbrms::pp_check(m_poisson_OLRE, type = \"dens_overlay\", ndraws = 200) + theme(legend.position = \"none\") + brms::pp_check(m_poisson_OLRE, type = \"intervals\") +\n    plot_annotation(subtitle = \"OLRE PPC: The wrong way\") \n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nobs_idx = np.arange(len(Kline))\ncoords = {\"obs\": obs_idx}\n\nwith pm.Model(coords = coords) as m_poisson_OLRE:\n    # priors\n    b0 = pm.Normal(\"Intercept\", mu=3, sigma=0.5)\n    b_pop = pm.Normal(\"slope\", mu=0, sigma=0.2)\n    nu = pm.Normal(\"nu\", mu = 0, sigma = 1, dims = \"obs\")\n    sigma = pm.Exponential(\"sigma\", lam = 2)\n    # linear model\n    log_lam = b0 + nu[obs_idx]*sigma + b_pop * Kline['log_pop_z'] \n    ## Poisson likelihood\n    y = pm.Poisson(\"y\", mu=pm.math.exp(log_lam), observed=Kline['total_tools'])\n\n    idata_OLRE = pm.sample(4000, chains = 1, target_accept = 0.95, random_seed=123)\n    pm.sample_posterior_predictive(idata_OLRE, extend_inferencedata=True, random_seed=1);\n\n\nCode\n\nidata_OLRE.observed_data['y'] = idata_OLRE.observed_data['y'].astype(np.float64) # Convert observed data to float for visualization\nidata_OLRE.posterior_predictive['y'] = idata_OLRE.posterior_predictive['y'].astype(np.float64)\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 13))\n\nplot_ppc_dens(idata_OLRE.observed_data['y'], idata_OLRE.posterior_predictive['y'], axes, 0)\nplot_ppc_intervals(idata_OLRE.observed_data['y'], idata_OLRE.posterior_predictive['y'], axes, 1)\naxes[0].set_title('OLRE PPC: The wrong way', loc = \"left\")\n\n\n\n\n\nIncorrect posterior predictive checks for OLRE Poisson model, using off-the-shelf convenience functions. (left) replicated and observed densities, (right) observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\nLooks good, right? Sadly, this is a little too good to be true. We have misled ourselves. To see why, let’s examine the \\(\\nu_{\\text{obs}}\\) parameters in relation to the observed data:\n\nbrmsPyMC\n\n\n\n\nCode\nm_poisson_OLRE |&gt; \n    spread_draws(r_obs[obs]) |&gt; \n    median_qi(estimate = r_obs, .width = 0.9) |&gt; \n    left_join(Kline, by = \"obs\") |&gt; \n    ggplot(aes(x = estimate, y = log(total_tools), xmin = .lower, xmax = .upper)) +\n    geom_pointinterval() + \n    theme_classic(base_size = 15) + \n    labs(x = expression(nu), y = \"log(total tools)\", title = \"y ~ Fitted OLRE\")\n\n\n\n\n\nFitted nu parameters as a function of the natural log of the response, total tools. Bars represent 90% credible intervals.\n\n\n\n\n\n\n\n\nCode\nstats = az.summary(idata_OLRE, var_names=[\"^nu.*\"], filter_vars=\"regex\", hdi_prob=0.9)\n\nfig = plt.figure(figsize=(20, 13))\nplt.hlines(y=np.log(Kline['total_tools']), xmin=stats['hdi_5%'], xmax = stats['hdi_95%'], color=\"black\", linewidth=6)\nplt.scatter(y=np.log(Kline['total_tools']), x=stats['mean'], color=\"black\", s = 150)\n\nplt.title('y ~ Fitted OLRE', loc = \"left\")\nplt.xlabel(r'$\\nu$')\nplt.ylabel('log(total tools)')\n\n\n\n\n\nFitted nu parameters as a function of the natural log of the response, total tools. Bars represent 90% credible intervals.\n\n\n\n\n\n\n\nThis plot shows us that the OLREs are positively correlated with the values of the observed data. Why? These parameters are doing exactly what they are supposed to do: capture excess dispersion in the data by learning which points are higher or lower than we would expect, given their population size. To understand why this is a problem, consider out-of-sample prediction: when generating \\(y_\\text{rep}\\) for a new observation, we don’t know \\(y_{\\text{test}}\\) in advance, so the OLRE should convey no information about it. In our naive predictive check, we have mistakenly treated \\(\\nu\\) as fixed, when really it should be replicated along with \\(y_\\text{rep}\\), akin to \\(\\epsilon\\) in a linear regression. Generating \\(y_\\text{rep}\\) this way is referred to as “mixed replication”, because we leave the hyperparameter \\(\\sigma\\) fixed but replicate each random effect parameter (Gelman, Meng, and Stern 1996).\n\n\nThe right way\nThe way out of this is straightforward. All we have to do is replace the fitted OLREs with new levels, denoted \\(\\nu_{\\text{rep}}\\), which are generated using posterior draws of the observation-level standard deviation \\(\\sigma\\).\n\nbrmsPyMC\n\n\n\n\nCode\nyrep_OLRE &lt;- m_poisson_OLRE |&gt; \n    posterior_predict(newdata = Kline |&gt; \n    mutate(obs = paste(\"OLRE_rep\", 1:n())),\n     allow_new_levels = TRUE,\n     sample_new_levels = \"gaussian\")\n\nbayesplot::ppc_dens_overlay(Kline$total_tools, yrep_OLRE[1:100,]) + theme(legend.position = \"none\") + bayesplot::ppc_intervals(Kline$total_tools, yrep_OLRE) +\n    plot_annotation(subtitle = \"OLRE PPC: The right way\") \n\n\n\n\n\nCorrect posterior predictive checks for OLRE Poisson model, sampling new levels of nu (nu_rep). (left) replicated and observed densities, (right) observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\n\nCode\nimport xarray as xr\n\nwith m_poisson_OLRE:\n    nu_rep = pm.Normal(\"nu_rep\", mu = 0, sigma = sigma, shape = len(Kline))\n    log_lam = b0 + nu_rep + b_pop * Kline['log_pop_z']\n    yrep = pm.Poisson(\"yrep\", pm.math.exp(log_lam))\n\npred_yrep = pm.sample_posterior_predictive(idata_OLRE, m_poisson_OLRE, predictions=True, extend_inferencedata=False, var_names = ['nu_rep', 'yrep'], random_seed=2)\n\n\nCode\n\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 13))\n\nplot_ppc_dens(idata.observed_data['y'], pred_yrep.predictions['yrep'], axes, 0)\nplot_ppc_intervals(idata.observed_data['y'], pred_yrep.predictions['yrep'], axes, 1)\naxes[0].set_title('OLRE PPC: The right way', loc = \"left\")\n\n\n\n\n\nCorrect posterior predictive checks for OLRE Poisson model, sampling new levels of nu (nu_rep). (left) replicated and observed densities, (right) observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\nNotice that, unlike our first predictive check with no OLRE, the credible intervals of \\(y_{\\text{rep}}\\) all contain the observed values of y. But unlike our (wrong) second predictive check, the predictions do not conform so closely to the observed values, because each \\(\\nu_{\\text{rep}}\\) is independent of \\(y\\). This provides us with a more realistic picture of our model’s fit. So, why do most posterior predictive functions treat OLREs the wrong way by default? Because the software doesn’t know whether \\(\\nu\\) is an OLRE or instead a parameter that should be fixed across replications, like random effects for group differences. The latter is more common, so the default is sensible–but not necessarily safe.\nThere is a caveat: even if we do it the “right way”, all posterior predictive checks are overly optimistic for out-of-sample data because they use the same data for fitting and evaluation. A model that performs well in these checks might actually have poor generalization to new data due to overfitting. This issue is not specific to OLREs, but in the final section I’ll show you how to address overfitting in predictive checks.\n\n\nAn even better way?\nLeave-one-out cross validation (LOOCV) provides a more honest assessment of predictive accuracy by holding out one observation at a time as a test point. Since the model never sees the held-out observation during fitting, these model checks will reflect true predictive performance rather than retrodiction of the sample. In the code below perform exact LOOCV, refitting the model and making predictions for the left-out point \\(N = 10\\) times.\n\nbrmsPyMC\n\n\n\n\nCode\nyrep_loo &lt;- matrix(NA, nrow = ndraws(m_poisson_OLRE), ncol = nrow(Kline))\n\nfor (i in 1:nrow(Kline)) {\n    model_loo &lt;- update(m_poisson_OLRE, newdata = Kline[-i,], seed = 123)\n    yrep_loo[,i] &lt;- posterior_predict(model_loo, newdata = Kline[i,], allow_new_levels = TRUE, sample_new_levels = \"gaussian\")\n}\n\nbayesplot::ppc_dens_overlay(Kline$total_tools, yrep_loo[1:100,]) + theme(legend.position = \"none\") + bayesplot::ppc_intervals(Kline$total_tools, yrep_loo) +\n    plot_annotation(subtitle = \"OLRE PPC-LOO\") \n\n\n\n\n\nLOOCV posterior predictive checks for OLRE Poisson model. Observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\n\nCode\ndef model_factory(train, test):\n    obs_idx = np.arange(len(train))\n    coords = {\"obs\": obs_idx}\n\n    with pm.Model(coords = coords) as model:\n        b0 = pm.Normal(\"Intercept\", mu=3, sigma=0.5)\n        b_pop = pm.Normal(\"slope\", mu=0, sigma=0.2)\n        nu = pm.Normal(\"nu\", mu = 0, sigma = 1, dims = \"obs\")\n        sigma = pm.Exponential(\"sigma\", lam = 2)\n        # linear model\n        log_lam = b0 + nu[obs_idx]*sigma + b_pop * train['log_pop_z'] \n        ## Poisson likelihood\n        y = pm.Poisson(\"y\", mu=pm.math.exp(log_lam), observed=train['total_tools'])\n\n        nu_rep = pm.Normal(\"nu_rep\", mu = 0, sigma = sigma)\n        yrep = pm.Poisson(\"yrep\", pm.math.exp(b0 + nu_rep + b_pop * test['log_pop_z']))\n    \n        idata_loo = pm.sample(1000, chains = 1, target_accept = 0.99, random_seed=2)\n    \n    pred = pm.sample_posterior_predictive(idata_loo, model, predictions=True, extend_inferencedata=False, var_names = ['yrep'], random_seed=2)\n\n    return pred.predictions['yrep']\n\ntest_preds = []\n\nfor i in range(len(Kline)):\n    train = Kline.drop(index = Kline.index[i])\n    test = Kline.iloc[[i]]\n    yrep_loo = model_factory(train, test)\n    test_preds.append(yrep_loo)\n\n\nCode\n\nloo_preds_combined = xr.concat(test_preds, dim='obs').transpose('chain', 'draw', 'obs', 'yrep_dim_2').squeeze('yrep_dim_2')\n        \nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 13))\nplot_ppc_dens(idata.observed_data['y'], loo_preds_combined, axes, 0)\nplot_ppc_intervals(idata.observed_data['y'], loo_preds_combined, axes, 1)\naxes[0].set_title('OLRE PPC-LOO', loc = \"left\")\n\n\n\n\n\nExact LOOCV posterior predictive checks for OLRE Poisson model. Observation-level reps, with bars representing 50% and 90% credible intervals.\n\n\n\n\n\n\n\nThis predictive check is even less optimistic, but it still looks better than the first Poisson model we fit, suggesting that the OLRE is helpful. For large datasets, it becomes infeasible to refit the model for each observation, so one might turn to k-fold cross validation or Pareo-smoothed importance sampling as an approximation (PSIS-LOO) (Vehtari, Gelman, and Gabry 2017). Note that PSIS may not reliable for these types of models, and one should instead integrate out the OLREs using adaptive quadrature.\n\n\nReproducible environment\nR session info\nConda environment\n\n\n\n\n\n\n\n\nReferences\n\nGelman, Andrew, Xiao-Li Meng, and Hal Stern. 1996. “Posterior Predictive Assessment of Model Fitness via Realized Discrepancies.” Statistica Sinica, 733–60.\n\n\nHadfield, Jarrod D. 2010. “MCMC Methods for Multi-Response Generalized Linear Mixed Models: The MCMCglmm r Package.” Journal of Statistical Software 33: 1–22.\n\n\nHarrison, Xavier A. 2014. “Using Observation-Level Random Effects to Model Overdispersion in Count Data in Ecology and Evolution.” PeerJ 2: e616.\n\n\n———. 2015. “A Comparison of Observation-Level Random Effect and Beta-Binomial Models for Modelling Overdispersion in Binomial Data in Ecology & Evolution.” PeerJ 3: e1114.\n\n\nKline, Michelle A, and Robert Boyd. 2010. “Population Size Predicts Technological Complexity in Oceania.” Proceedings of the Royal Society B: Biological Sciences 277 (1693): 2559–64.\n\n\nMcElreath, Richard. 2020. “Statistical Rethinking: A Bayesian Course with Examples in r and Stan.” In, 2nd ed., 350. Chapman; Hall/CRC.\n\n\nVehtari, Aki, Andrew Gelman, and Jonah Gabry. 2017. “Practical Bayesian Model Evaluation Using Leave-One-Out Cross-Validation and WAIC.” Statistics and Computing 27: 1413–32."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Just Another Stats Blog",
    "section": "",
    "text": "The right way to do predictive checks with observation-level random effects\n\n\n\n\n\n\nPrediction\n\n\nStatistics\n\n\nbrms\n\n\nPyMC\n\n\n\n\n\n\n\n\n\nNov 10, 2024\n\n\nErik J. Ringen\n\n\n\n\n\n\nNo matching items"
  }
]